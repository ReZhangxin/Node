# Node.js

## Node.js三大特点

- **单线程**
- **非阻塞I/O**
- **事件驱动**

### 单线程

> 在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程。
> 而每个线程需要耗费大约2MB内存。也就是说，理论上，
> 一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。
> 要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。

-----

> Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。
> 当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，
> 让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。
> 另外，带线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

![多线程](http://owk6ztygn.bkt.clouddn.com/1.png)

![单线程](http://owk6ztygn.bkt.clouddn.com/2.png)

### 非阻塞I/O

当在访问数据库取得数据的时候，需要一段时间。
在传统的单线程处理机制中，在执行了访问数据库代码之后，整个线程都将暂停下来，等待数据库返回结果，
才能执行后面的代码。也就是说，**I/O阻塞了代码的执行，极大地降低了程序的执行效率。**

-----

由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库的代码之后，
将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。

当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。
为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。

而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。

### 事件驱动

在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。
在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，
可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，
这种处理机制，称为“事件环”机制。

![事件环机制](http://owk6ztygn.bkt.clouddn.com/3.png)

- **单线程**，单线程的好处，减少了内存开销，操作系统的内存换页。如果某一个事情，进入了，但是被I/O阻塞了，所以这个线程就阻塞了。

- **非阻塞I/O**， 不会傻等I/O语句结束，而会执行后面的语句。非阻塞就能解决问题了么？比如执行着小红的业务，执行过程中，小刚的I/O回调完成了，此时怎么办？？

- **事件驱动**，不管是新用户的请求，还是老用户的I/O完成，都将以事件方式加入事件环，等待调度。

## Node适合什么

善于I/O，不善于计算。因为Node.js最擅长的就是任务调度，如果你的业务有很多的CPU计算，实际上也相当于这个计算阻塞了这个单线程，就不适合Node开发。
当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。

-----

- 用户表单收集
- 考试系统
- 聊天室
- 图文直播
- 提供JSON的API（为前台Angular使用）

[将图片转换成字符画](http://www.degraeve.com/img2txt.php)